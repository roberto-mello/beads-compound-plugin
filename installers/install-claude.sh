#!/bin/bash
#
# Install beads-compound plugin into a project
#
# What this installs:
#   - Memory capture and auto-recall hooks
#   - Knowledge store (.beads/memory/knowledge.jsonl)
#   - Recall script (.beads/memory/recall.sh)
#   - Beads-aware workflow commands (25 commands)
#   - Specialized agents (28 agent definitions)
#   - Skills (15 skills including git-worktree, brainstorming, etc.)
#   - MCP server configuration (Context7)
#
# Usage:
#   Global installation (recommended):
#     ./install.sh                          # installs to ~/.claude
#
#   Project-specific installation:
#     ./install.sh /path/to/your-project
#
#   From anywhere:
#     bash /path/to/beads-compound-plugin/install.sh
#     bash /path/to/beads-compound-plugin/install.sh /path/to/your-project
#

set -euo pipefail

# Use marketplace root from router if available, else derive from script location
if [ -n "${BEADS_MARKETPLACE_ROOT:-}" ]; then
  SCRIPT_DIR="$BEADS_MARKETPLACE_ROOT"
else
  SCRIPT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
fi

PLUGIN_DIR="$SCRIPT_DIR/plugins/beads-compound"

# Source shared functions
# Use BASH_SOURCE to get the correct path when sourced
INSTALLER_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$INSTALLER_DIR/shared-functions.sh"

# Parse --yes/-y flag (skip confirmation prompts)
AUTO_YES=false
POSITIONAL_ARGS=()

for arg in "$@"; do
  case "$arg" in
    --yes|-y) AUTO_YES=true ;;
    *) POSITIONAL_ARGS+=("$arg") ;;
  esac
done

# Default to ~/.claude if no positional argument provided
if [ ${#POSITIONAL_ARGS[@]} -eq 0 ]; then
  TARGET="$HOME/.claude"
  GLOBAL_INSTALL=true
else
  TARGET="${POSITIONAL_ARGS[0]}"
  GLOBAL_INSTALL=false
fi

# Resolve target to absolute path
TARGET="$(resolve_target_dir "$TARGET")"

# Detect if user is trying to install into the plugin directory itself
if [[ "$TARGET" == "$SCRIPT_DIR" || "$TARGET" == "$PLUGIN_DIR" ]]; then
  echo "[!] Error: Cannot install plugin into itself."
  echo ""
  echo "    You're trying to install into: $TARGET"
  echo "    This is the plugin source directory, not a project."
  echo ""
  echo "    Usage:"
  echo "      ./install.sh                      # global install to ~/.claude"
  echo "      ./install.sh /path/to/project     # project-specific install"
  echo ""
  exit 1
fi

# Verify plugin directory exists
if [ ! -d "$PLUGIN_DIR" ]; then
  echo "[!] Error: Plugin directory not found at $PLUGIN_DIR"
  echo "    Expected marketplace structure with plugins/beads-compound/"
  exit 1
fi

echo "beads-compound plugin installer"
echo "Plugin: $PLUGIN_DIR"
if [ "$GLOBAL_INSTALL" = true ]; then
  echo "Target: $TARGET (global)"
else
  echo "Target: $TARGET (project-specific)"
fi
echo ""

# Global install: warn about memory features and confirm
if [ "$GLOBAL_INSTALL" = true ] && [ "$AUTO_YES" = false ]; then
  echo "[!] Note: Global install provides commands, agents, and skills everywhere,"
  echo "    but memory features (auto-recall, knowledge capture) require per-project"
  echo "    installation. You'll be prompted automatically in projects that use beads."
  echo ""
  read -r -p "    Continue? [Y/n] " response
  case "$response" in
    [nN]|[nN][oO])
      echo "Aborted."
      exit 0
      ;;
  esac
  echo ""
fi

# Check for bd (skip for global install)
if [ "$GLOBAL_INSTALL" = true ]; then
  echo "[1/9] Skipping bd check (global install)"
  echo "[2/9] Skipping .beads init (global install)"
else
  if ! command -v bd &>/dev/null; then
    echo "[!] beads CLI (bd) not found."
    echo ""
    echo "    Install it first:"
    echo "      macOS:  brew install steveyegge/beads/bd"
    echo "      npm:    npm install -g @beads/bd"
    echo "      go:     go install github.com/steveyegge/beads/cmd/bd@latest"
    echo ""
    exit 1
  fi

  echo "[1/9] bd found: $(which bd)"

  # Initialize .beads if needed
  if [ ! -d "$TARGET/.beads" ]; then
    echo "[2/9] Initializing .beads..."
    (cd "$TARGET" && bd init)
  else
    echo "[2/9] .beads already exists"
  fi
fi

# Set up memory directory and recall script (skip for global install)
if [ "$GLOBAL_INSTALL" = true ]; then
  echo "[3/9] Skipping memory system (global install)"
else
  echo "[3/9] Setting up memory system..."

  PROVISION_SCRIPT="$PLUGIN_DIR/hooks/provision-memory.sh"

  if [ -f "$PROVISION_SCRIPT" ]; then
    source "$PROVISION_SCRIPT"
    provision_memory_dir "$TARGET" "$PLUGIN_DIR/hooks"
    echo "  - Memory system configured"
  fi
fi

# Install hooks (only for project-specific installs)
if [ "$GLOBAL_INSTALL" = true ]; then
  echo "[4/9] Skipping hooks (use project-specific install for beads integration)"
else
  echo "[4/9] Installing hooks..."

  HOOKS_DIR="$TARGET/.claude/hooks"
  create_dir_with_symlink_handling "$HOOKS_DIR"

  for hook in memory-capture.sh auto-recall.sh subagent-wrapup.sh knowledge-db.sh provision-memory.sh; do
    cp "$PLUGIN_DIR/hooks/$hook" "$HOOKS_DIR/$hook"
    chmod +x "$HOOKS_DIR/$hook"
    echo "  - Installed $hook"
  done
fi

# Detect if commands/agents/skills are already installed globally
GLOBALLY_INSTALLED=false

if [ "$GLOBAL_INSTALL" = false ] && [ -f "$HOME/.claude/commands/beads-plan.md" ]; then
  GLOBALLY_INSTALLED=true
fi

# Install commands (all from commands directory)
echo "[5/9] Installing workflow commands..."

if [ "$GLOBALLY_INSTALLED" = true ]; then
  CMD_COUNT=0
  echo "  - Already installed globally -- skipping"
else
  if [ "$GLOBAL_INSTALL" = true ]; then
    COMMANDS_DIR="$TARGET/commands"
  else
    COMMANDS_DIR="$TARGET/.claude/commands"
  fi
  create_dir_with_symlink_handling "$COMMANDS_DIR"

  CMD_COUNT=0

  for cmd in "$PLUGIN_DIR/commands"/*.md; do
    if [ -f "$cmd" ]; then
      cp "$cmd" "$COMMANDS_DIR/$(basename "$cmd")"
      ((CMD_COUNT++))
    fi
  done

  echo "  - Installed $CMD_COUNT commands"
fi

# Install agents
echo "[6/9] Installing agents..."

if [ "$GLOBALLY_INSTALLED" = true ]; then
  AGENT_COUNT=0
  echo "  - Already installed globally -- skipping"
else
  if [ "$GLOBAL_INSTALL" = true ]; then
    AGENTS_DIR="$TARGET/agents"
  else
    AGENTS_DIR="$TARGET/.claude/agents"
  fi
  mkdir -p "$AGENTS_DIR"

  AGENT_COUNT=0

  if [ -d "$PLUGIN_DIR/agents" ]; then
    for category in "$PLUGIN_DIR/agents"/*/; do
      if [ -d "$category" ]; then
        category_name=$(basename "$category")
        mkdir -p "$AGENTS_DIR/$category_name"

        for agent in "$category"/*.md; do
          if [ -f "$agent" ]; then
            cp "$agent" "$AGENTS_DIR/$category_name/$(basename "$agent")"
            ((AGENT_COUNT++))
          fi
        done
      fi
    done
  fi

  echo "  - Installed $AGENT_COUNT agents"
fi

# Install skills
echo "[7/9] Installing skills..."

SKILL_COUNT=0
SKILL_SKIPPED=0

if [ "$GLOBALLY_INSTALLED" = true ]; then
  echo "  - Already installed globally -- skipping"
else
  if [ "$GLOBAL_INSTALL" = true ]; then
    SKILLS_DIR="$TARGET/skills"
  else
    SKILLS_DIR="$TARGET/.claude/skills"
  fi
  mkdir -p "$SKILLS_DIR"

  if [ -d "$PLUGIN_DIR/skills" ]; then
    for skill_dir in "$PLUGIN_DIR/skills"/*/; do
      if [ -d "$skill_dir" ]; then
        skill_name=$(basename "$skill_dir")

        if [ -L "$SKILLS_DIR/$skill_name" ]; then
          # Symlink -- installed by Claude's plugin system, don't touch
          echo "  - Skipped $skill_name (symlink, not ours)"
          ((SKILL_SKIPPED++))
          continue
        elif [ -d "$SKILLS_DIR/$skill_name" ]; then
          if [ -f "$SKILLS_DIR/$skill_name/.beads-compound" ]; then
            # Our plugin installed this -- safe to overwrite
            rm -rf "$SKILLS_DIR/$skill_name"
          else
            # User's own skill -- skip it
            echo "  - Skipped $skill_name (already exists, not ours)"
            ((SKILL_SKIPPED++))
            continue
          fi
        fi

        # Copy entire skill directory (may contain references/, templates/, etc.)
        cp -r "$skill_dir" "$SKILLS_DIR/$skill_name"
        touch "$SKILLS_DIR/$skill_name/.beads-compound"
        ((SKILL_COUNT++))
      fi
    done
  fi

  echo "  - Installed $SKILL_COUNT skills"
  if [ "$SKILL_SKIPPED" -gt 0 ]; then
    echo "  - Skipped $SKILL_SKIPPED existing skill(s) not managed by this plugin"
  fi
fi

# Install MCP configuration
echo "[8/9] Configuring MCP servers..."

if [ "$GLOBALLY_INSTALLED" = true ]; then
  # Check if MCP is already configured globally
  if [ -f "$HOME/.mcp.json" ] && command -v jq &>/dev/null; then
    if jq -e '.mcpServers["context7"]' "$HOME/.mcp.json" &>/dev/null; then
      echo "  - Already configured globally -- skipping"
    else
      # Global install exists but MCP wasn't set up -- install it
      if [ -f "$PLUGIN_DIR/.mcp.json" ]; then
        if [ -f "$TARGET/.mcp.json" ]; then
          EXISTING=$(cat "$TARGET/.mcp.json")
          PLUGIN_MCP=$(cat "$PLUGIN_DIR/.mcp.json")
          MERGED=$(printf '%s\n%s\n' "$EXISTING" "$PLUGIN_MCP" | jq -s '.[0].mcpServers = ((.[0].mcpServers // {}) * .[1].mcpServers) | .[0]')
          echo "$MERGED" > "$TARGET/.mcp.json"
          echo "  - Merged MCP servers into existing .mcp.json"
        else
          cp "$PLUGIN_DIR/.mcp.json" "$TARGET/.mcp.json"
          echo "  - Created .mcp.json with Context7 MCP server"
        fi
      fi
    fi
  else
    echo "  - Already installed globally -- skipping"
  fi
else
  if [ -f "$PLUGIN_DIR/.mcp.json" ]; then
    if [ -f "$TARGET/.mcp.json" ]; then
      if command -v jq &>/dev/null; then
        # Merge MCP servers into existing config
        EXISTING=$(cat "$TARGET/.mcp.json")
        PLUGIN_MCP=$(cat "$PLUGIN_DIR/.mcp.json")
        MERGED=$(printf '%s\n%s\n' "$EXISTING" "$PLUGIN_MCP" | jq -s '.[0].mcpServers = ((.[0].mcpServers // {}) * .[1].mcpServers) | .[0]')
        echo "$MERGED" > "$TARGET/.mcp.json"
        echo "  - Merged MCP servers into existing .mcp.json"
      else
        echo "  [!] jq not found -- skipping MCP merge (manual setup required)"
      fi
    else
      cp "$PLUGIN_DIR/.mcp.json" "$TARGET/.mcp.json"
      echo "  - Created .mcp.json with Context7 MCP server"
    fi
  else
    echo "  - No MCP configuration found in plugin"
  fi
fi

# Wire up settings.json
if [ "$GLOBAL_INSTALL" = true ]; then
  echo "[9/9] Configuring global settings..."

  # Install all hook scripts for auto-installation in beads projects
  mkdir -p "$TARGET/hooks"

  for hook in check-memory.sh auto-recall.sh memory-capture.sh subagent-wrapup.sh knowledge-db.sh provision-memory.sh recall.sh; do
    if [ -f "$PLUGIN_DIR/hooks/$hook" ]; then
      cp "$PLUGIN_DIR/hooks/$hook" "$TARGET/hooks/$hook"
      chmod +x "$TARGET/hooks/$hook"
    fi
  done

  echo "  - Installed hook scripts (check-memory + memory hooks for auto-install)"

  # Add SessionStart hook for check-memory to global settings.json
  SETTINGS="$TARGET/settings.json"

  if [ -f "$SETTINGS" ]; then
    if command -v jq &>/dev/null; then
      EXISTING=$(cat "$SETTINGS")

      UPDATED=$(echo "$EXISTING" | jq --arg cmd "bash ~/.claude/hooks/check-memory.sh" '
        .hooks.SessionStart = (
          [(.hooks.SessionStart // [])[] | select(.hooks[]?.command | contains("check-memory") | not)] +
          [{"matcher":"","hooks":[{"type":"command","command":$cmd}]}]
        )
      ')
      echo "$UPDATED" > "$SETTINGS"
      echo "  - Added check-memory hook to settings.json"
    else
      echo "  [!] jq not found -- manual settings.json setup required"
    fi
  else
    cat > "$SETTINGS" << SETTINGS_EOF
{
  "hooks": {
    "SessionStart": [
      {"matcher": "", "hooks": [{"type": "command", "command": "bash ~/.claude/hooks/check-memory.sh"}]}
    ]
  }
}
SETTINGS_EOF
    echo "  - Created settings.json with check-memory hook"
  fi
else
  echo "[9/9] Configuring settings..."

  SETTINGS="$TARGET/.claude/settings.json"

  if [ -f "$SETTINGS" ]; then
    if command -v jq &>/dev/null; then
      EXISTING=$(cat "$SETTINGS")

      UPDATED=$(echo "$EXISTING" | jq '
        # Add/update SessionStart hook
        .hooks.SessionStart = (
          [(.hooks.SessionStart // [])[] | select(.hooks[]?.command | contains("auto-recall") | not)] +
          [{"hooks":[{"type":"command","command":"bash .claude/hooks/auto-recall.sh","async":true}]}]
        ) |
        # Add/update PostToolUse hook with matcher
        .hooks.PostToolUse = (
          [(.hooks.PostToolUse // [])[] | select(.hooks[]?.command | contains("memory-capture") | not)] +
          [{"matcher":"Bash","hooks":[{"type":"command","command":"bash .claude/hooks/memory-capture.sh","async":true}]}]
        ) |
        # Add/update SubagentStop hook for auto-wrapup
        .hooks.SubagentStop = (
          [(.hooks.SubagentStop // [])[] | select(.hooks[]?.command | contains("subagent-wrapup") | not)] +
          [{"hooks":[{"type":"command","command":"bash .claude/hooks/subagent-wrapup.sh"}]}]
        ) |
        # Remove any null hook arrays
        if .hooks.PreToolUse == null then del(.hooks.PreToolUse) else . end |
        if .hooks.SubagentStop == null then del(.hooks.SubagentStop) else . end
      ')
      echo "$UPDATED" > "$SETTINGS"
      echo "  - Merged hooks into existing settings.json"
    else
      echo "  [!] jq not found -- manual settings.json setup required"
      echo "      Add SessionStart and PostToolUse hooks manually"
    fi
  else
    mkdir -p "$(dirname "$SETTINGS")"
    cat > "$SETTINGS" << 'SETTINGS_EOF'
{
  "hooks": {
    "SessionStart": [
      {"hooks": [{"type": "command", "command": "bash .claude/hooks/auto-recall.sh", "async": true}]}
    ],
    "PostToolUse": [
      {"matcher": "Bash", "hooks": [{"type": "command", "command": "bash .claude/hooks/memory-capture.sh", "async": true}]}
    ],
    "SubagentStop": [
      {"hooks": [{"type": "command", "command": "bash .claude/hooks/subagent-wrapup.sh"}]}
    ]
  }
}
SETTINGS_EOF
    echo "  - Created settings.json"
  fi
fi

# Update .gitignore (only for project-specific installs)
if [ "$GLOBAL_INSTALL" = false ]; then
  GITIGNORE="$TARGET/.gitignore"

  if [ -f "$GITIGNORE" ]; then
    if ! grep -qE '^\.beads/?$' "$GITIGNORE" 2>/dev/null; then
      echo "" >> "$GITIGNORE"
      echo "# Beads (ephemeral task data)" >> "$GITIGNORE"
      echo ".beads/" >> "$GITIGNORE"
      echo "  - Updated .gitignore"
    fi
  else
    cat > "$GITIGNORE" << 'EOF'
# Beads (ephemeral task data)
.beads/
.mcp.json
EOF
    echo "  - Created .gitignore"
  fi
fi

# Check for recommended frontend skills
FRONTEND_SKILLS_MISSING=()

GLOBAL_SKILLS="$HOME/.claude/skills"
PROJECT_SKILLS="$TARGET/.claude/skills"

if [ ! -f "$GLOBAL_SKILLS/web-design-guidelines.md" ] && [ ! -f "$PROJECT_SKILLS/web-design-guidelines.md" ]; then
  FRONTEND_SKILLS_MISSING+=("web-design-guidelines")
fi

if [ ! -f "$GLOBAL_SKILLS/vercel-react-best-practices.md" ] && [ ! -f "$PROJECT_SKILLS/vercel-react-best-practices.md" ]; then
  FRONTEND_SKILLS_MISSING+=("vercel-react-best-practices")
fi

echo ""
echo "Done. Installed:"
echo ""
echo "  Commands ($CMD_COUNT):"
echo "    Workflow: /beads-plan, /beads-brainstorm, /beads-work, /beads-parallel, /beads-review, /beads-compound, /beads-checkpoint"
echo "    Planning: /beads-deepen, /beads-plan-review, /beads-triage"
echo "    Utility:  /lfg, /changelog, /create-agent-skill, /generate-command, /heal-skill"
echo "    Testing:  /test-browser, /xcode-test, /reproduce-bug, /report-bug"
echo "    Docs:     /deploy-docs, /release-docs, /feature-video, /agent-native-audit"
echo "    Parallel: /resolve-pr-parallel, /resolve-todo-parallel"
echo ""
echo "  Agents ($AGENT_COUNT):"
echo "    Review, research, design, workflow, and docs agents"
echo ""
echo "  Skills ($SKILL_COUNT):"
echo "    git-worktree, brainstorming, create-agent-skills, agent-native-architecture, beads-knowledge,"
echo "    agent-browser, andrew-kane-gem-writer, dhh-rails-style, dspy-ruby, every-style-editor,"
echo "    file-todos, frontend-design, gemini-imagegen, rclone, skill-creator"
echo ""

if [ "$GLOBAL_INSTALL" = false ]; then
  echo "  Memory System:"
  echo "    - Auto-recall at session start (based on current beads)"
  echo "    - Auto-capture from bd comment (LEARNED/DECISION/FACT/PATTERN/INVESTIGATION)"
  echo "    - Knowledge stored at .beads/memory/knowledge.jsonl"
  echo "    - Search: .beads/memory/recall.sh \"keyword\""
  echo ""
fi

echo "  MCP Servers:"
echo "    - Context7 (framework documentation)"
echo ""

if [ ${#FRONTEND_SKILLS_MISSING[@]} -gt 0 ]; then
  echo "Recommended (frontend projects):"
  for skill in "${FRONTEND_SKILLS_MISSING[@]}"; do
    echo "  - Install $skill skill for enhanced review capabilities"
  done
  echo ""
  echo "  Install globally:"
  for skill in "${FRONTEND_SKILLS_MISSING[@]}"; do
    echo "    claude-code skill add $skill"
  done
  echo ""
  echo "  Or per-project:"
  echo "    cd $TARGET"
  for skill in "${FRONTEND_SKILLS_MISSING[@]}"; do
    echo "    claude-code skill add $skill --project"
  done
  echo ""
fi

if [ "$GLOBAL_INSTALL" = true ]; then
  echo "Global installation complete!"
  echo ""
  echo "Commands, agents, and skills are now available in all Claude Code sessions."
  echo ""
  echo "For beads integration (memory system + hooks):"
  echo "  bash $SCRIPT_DIR/install.sh /path/to/your-project"
  echo ""
else
  echo "Usage:"
  echo "  1. Create or work on beads normally with bd commands"
  echo "  2. Use /beads-plan for complex features requiring research"
  echo "  3. Use /beads-brainstorm to explore ideas before planning"
  echo "  4. Use /beads-review before closing beads to catch issues"
  echo "  5. Log learnings with: bd comment add ID \"LEARNED: ...\""
  echo "  6. Knowledge will be recalled automatically next session"
  echo ""
fi

echo "Restart Claude Code to load the plugin."
echo ""

if [ "$GLOBAL_INSTALL" = false ]; then
  echo "To uninstall: bash $SCRIPT_DIR/uninstall.sh $TARGET"
fi
