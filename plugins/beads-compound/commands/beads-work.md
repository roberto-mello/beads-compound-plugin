---
name: beads-work
description: Execute work on a bead efficiently while maintaining quality and finishing features
argument-hint: "[bead ID or path to specification]"
---

# Work Plan Execution Command

Execute work on a bead efficiently while maintaining quality and finishing features.

## Introduction

This command takes a bead (or specification) and executes it systematically. The focus is on **shipping complete features** by understanding requirements quickly, following existing patterns, and maintaining quality throughout.

## Input

<input_document> #$ARGUMENTS </input_document>

## Execution Workflow

### Phase 1: Quick Start

1. **Read Bead and Clarify**

   If a bead ID was provided:
   ```bash
   bd show {BEAD_ID} --json
   ```

   Read the bead description completely including:
   - What section (implementation requirements)
   - Context section (research findings, constraints)
   - Testing section (test cases to implement)
   - Validation section (acceptance criteria)
   - Dependencies section (blockers)

   If a specification path was provided instead:
   - Read the document completely
   - Create a bead for tracking: `bd create "{title from spec}" -d "{spec content}" --type task`

   If nothing was provided:
   - Find the next ready bead: `bd ready --json | jq -r '.[0]'`
   - If no ready beads, list open beads and ask which to work on

   **Clarify ambiguities:**
   - If anything is unclear or ambiguous, use **AskUserQuestion tool** now
   - Get user approval to proceed
   - **Do not skip this** - better to ask questions now than build the wrong thing

2. **Recall Relevant Knowledge**

   ```bash
   # Search memory for relevant context
   .beads/memory/recall.sh "{keywords from bead title}"
   .beads/memory/recall.sh "{tech stack keywords}"
   ```

   Present any relevant LEARNED/DECISION/FACT/PATTERN entries.

3. **Check Dependencies & Related Beads**

   ```bash
   bd dep list {BEAD_ID} --json
   ```

   If there are unresolved blockers, list them and ask if the user wants to work on those first.

   Check for `relates_to` links in the dependency list. For each related bead, fetch its title and description:
   ```bash
   bd show {RELATED_BEAD_ID}
   ```
   Present related bead context to inform the work -- these beads share domain knowledge but don't block each other.

4. **Setup Environment**

   First, check the current branch:

   ```bash
   current_branch=$(git branch --show-current)
   default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
   if [ -z "$default_branch" ]; then
     default_branch=$(git rev-parse --verify origin/main >/dev/null 2>&1 && echo "main" || echo "master")
   fi
   ```

   **If already on a feature branch** (not the default branch):
   - Ask: "Continue working on `[current_branch]`, or create a new branch?"
   - If continuing, proceed to next step

   **If on the default branch**, choose how to proceed:

   **Option A: Create a new branch** (include bead ID in name)
   ```bash
   git pull origin [default_branch]
   git checkout -b bd-{BEAD_ID}/{short-description}
   ```

   **Option B: Use a worktree (recommended for parallel development)**
   ```bash
   skill: git-worktree
   ```

5. **Update Bead Status**

   ```bash
   bd update {BEAD_ID} --status in_progress
   ```

6. **Create Task List**
   - Use TaskCreate to break the bead description into actionable tasks
   - Use TaskUpdate with addBlockedBy/addBlocks for dependencies between tasks
   - Include testing and quality check tasks

### Phase 2: Execute

1. **Task Execution Loop**

   For each task in priority order:

   ```
   while (tasks remain):
     - Mark task as in_progress with TaskUpdate
     - Read any referenced files from the bead description
     - Look for similar patterns in codebase
     - Implement following existing conventions
     - Write tests for new functionality
     - Run tests after changes
     - Mark task as completed with TaskUpdate
     - Evaluate for incremental commit (see below)
   ```

2. **Incremental Commits**

   After completing each task, evaluate whether to create an incremental commit:

   | Commit when... | Don't commit when... |
   |----------------|---------------------|
   | Logical unit complete (model, service, component) | Small part of a larger unit |
   | Tests pass + meaningful progress | Tests failing |
   | About to switch contexts (backend -> frontend) | Purely scaffolding with no behavior |
   | About to attempt risky/uncertain changes | Would need a "WIP" commit message |

   **Heuristic:** "Can I write a commit message that describes a complete, valuable change? If yes, commit."

   **Commit workflow:**
   ```bash
   # 1. Verify tests pass
   # 2. Stage only related files (not `git add .`)
   git add <files related to this logical unit>
   # 3. Commit with conventional message
   git commit -m "feat(scope): description of this unit"
   ```

3. **Log Knowledge as You Work**

   When you discover something worth remembering:

   ```bash
   bd comments add {BEAD_ID} "LEARNED: {key technical insight}"
   bd comments add {BEAD_ID} "DECISION: {what was chosen and why}"
   bd comments add {BEAD_ID} "FACT: {constraint or gotcha discovered}"
   bd comments add {BEAD_ID} "PATTERN: {coding pattern followed}"
   ```

4. **Follow Existing Patterns**

   - The bead description should reference similar code - read those files first
   - Match naming conventions exactly
   - Reuse existing components where possible
   - Follow project coding standards (see CLAUDE.md or AGENTS.md)
   - When in doubt, grep for similar implementations

5. **Track Progress**
   - Keep task list updated (TaskUpdate) as you complete tasks
   - Note any blockers or unexpected discoveries
   - Create new tasks if scope expands
   - Keep user informed of major milestones

### Phase 3: Quality Check

1. **Run Core Quality Checks**

   Always run before submitting:

   ```bash
   # Run full test suite (use project's test command)
   # Run linting (per CLAUDE.md or AGENTS.md)
   ```

2. **Consider Reviewer Agents** (Optional)

   Use for complex, risky, or large changes:

   - **code-simplicity-reviewer**: Check for unnecessary complexity
   - **security-sentinel**: Scan for security vulnerabilities
   - **performance-oracle**: Check for performance issues

   Run reviewers in parallel with Task tool:

   ```
   Task(code-simplicity-reviewer): "Review changes for simplicity"
   Task(security-sentinel): "Security scan of changes"
   ```

   Present findings to user and address critical issues.

3. **Quick Simplicity Check**

   Run Task code-simplicity-reviewer() on the changes to catch unnecessary complexity before shipping.

4. **Final Validation**
   - All tasks marked completed (TaskList shows none pending)
   - All tests pass
   - Linting passes
   - Code follows existing patterns
   - Bead's validation criteria are met
   - No console errors or warnings

### Phase 4: Ship It

1. **Create Commit**

   ```bash
   git add <changed files>
   git status  # Review what's being committed
   git diff --staged  # Check the changes

   git commit -m "feat(scope): description of what and why"
   ```

2. **Create Pull Request**

   ```bash
   git push -u origin bd-{BEAD_ID}/{short-description}

   gh pr create --title "BD-{BEAD_ID}: {description}" --body "## Summary
   - What was built
   - Key decisions made

   ## Bead
   {BEAD_ID}: {bead title}

   ## Testing
   - Tests added/modified
   - Manual testing performed

   ## Knowledge Captured
   - {key learnings logged to bead}
   "
   ```

3. **Capture Final Knowledge**

   Log at least one knowledge comment summarizing the work:

   ```bash
   bd comments add {BEAD_ID} "LEARNED: {most important insight from this work}"
   ```

4. **Offer Next Steps**

   Use **AskUserQuestion tool**:

   **Question:** "Work complete on {BEAD_ID}. What next?"

   **Options:**
   1. **Run `/beads-review`** - Multi-agent code review before closing
   2. **Close bead** - Mark as complete: `bd close {BEAD_ID}`
   3. **Run `/beads-checkpoint`** - Save progress without closing
   4. **Continue working** - Keep implementing

## Key Principles

### Start Fast, Execute Faster

- Get clarification once at the start, then execute
- Don't wait for perfect understanding - ask questions and move
- The goal is to **finish the feature**, not create perfect process

### The Bead is Your Guide

- Bead descriptions should reference similar code and patterns
- Load those references and follow them
- Don't reinvent - match what exists

### Test As You Go

- Run tests after each change, not at the end
- Fix failures immediately
- Continuous testing prevents big surprises

### Quality is Built In

- Follow existing patterns
- Write tests for new code
- Run linting before pushing
- Use reviewer agents for complex/risky changes only

### Ship Complete Features

- Mark all tasks completed before moving on
- Don't leave features 80% done
- A finished feature that ships beats a perfect feature that doesn't

## Quality Checklist

Before creating PR, verify:

- [ ] All clarifying questions asked and answered
- [ ] All tasks marked completed (TaskList shows none pending)
- [ ] Tests pass (run project's test command)
- [ ] Linting passes
- [ ] Code follows existing patterns
- [ ] Bead validation criteria met
- [ ] Knowledge captured (at least one LEARNED/DECISION comment)
- [ ] Commit messages follow conventional format
- [ ] PR description includes bead reference and summary
