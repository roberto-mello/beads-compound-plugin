---
name: beads:review
description: Perform exhaustive code reviews using multi-agent analysis and ultra-thinking
argument-hint: "[bead ID, PR number, GitHub URL, branch name, or latest]"
---

# Review Command

<command_purpose> Perform exhaustive code reviews using multi-agent analysis, ultra-thinking, and Git worktrees for deep local inspection. </command_purpose>

## Introduction

<role>Senior Code Review Architect with expertise in security, performance, architecture, and quality assurance</role>

## Prerequisites

<requirements>
- Git repository with GitHub CLI (`gh`) installed and authenticated
- Clean main/master branch
- Proper permissions to create worktrees and access the repository
- `bd` CLI installed for bead management
</requirements>

## Main Tasks

### 1. Determine Review Target & Setup (ALWAYS FIRST)

<review_target> #$ARGUMENTS </review_target>

<thinking>
First, I need to determine the review target type and set up the code for analysis.
</thinking>

#### Immediate Actions:

- [ ] Determine review type: bead ID (BD-xxx), PR number (numeric), GitHub URL, or empty (current in-progress bead)
- [ ] If bead ID provided, get bead details: `bd show {BEAD_ID} --json`
- [ ] If no target provided, find current in-progress bead: `bd list --status in_progress --json | jq -r '.[0].id'`
- [ ] Check current git branch
- [ ] If ALREADY on the target branch -> proceed with analysis on current branch
- [ ] If DIFFERENT branch than the review target -> offer to use worktree: "Use git-worktree skill for isolated checkout." Call `skill: git-worktree` with branch name
- [ ] Fetch PR metadata using `gh pr view --json` for title, body, files, linked issues (if PR exists)
- [ ] Set up language-specific analysis tools
- [ ] Make sure we are on the branch we are reviewing

Ensure that the code is ready for analysis (either in worktree or on current branch). ONLY then proceed to the next step.

### 2. Recall Relevant Knowledge

Search for knowledge related to the code being reviewed:

```bash
# Extract keywords from bead title/description
.beads/memory/recall.sh "{keywords from bead title}"
.beads/memory/recall.sh "{tech stack keywords}"
.beads/memory/recall.sh --recent 10
```

Present any relevant LEARNED/DECISION/FACT/PATTERN entries that reviewers should consider.

#### Protected Artifacts

<protected_artifacts>
The following paths are beads-compound pipeline artifacts and must never be flagged for deletion, removal, or gitignore by any review agent:

- `.beads/memory/knowledge.jsonl` -- Persistent knowledge store
- `.beads/memory/knowledge.archive.jsonl` -- Archived knowledge
- `.beads/memory/recall.sh` -- Knowledge search script

If a review agent flags any file in `.beads/memory/` for cleanup or removal, discard that finding during synthesis. Do not create a bead for it.
</protected_artifacts>

### 3. Dispatch Review Agents in Parallel

<parallel_tasks>

Run ALL or most of these agents at the same time:

1. Task kieran-rails-reviewer(PR content)
2. Task dhh-rails-reviewer(PR content)
3. Task kieran-typescript-reviewer(PR content)
4. Task kieran-python-reviewer(PR content)
5. Task git-history-analyzer(PR content)
6. Task pattern-recognition-specialist(PR content)
7. Task architecture-strategist(PR content)
8. Task security-sentinel(PR content)
9. Task performance-oracle(PR content)
10. Task data-integrity-guardian(PR content)
11. Task agent-native-reviewer(PR content)
12. Task julik-frontend-races-reviewer(PR content)

</parallel_tasks>

#### Conditional Agents (Run if applicable):

<conditional_agents>

These agents are run ONLY when the PR matches specific criteria. Check the PR files list to determine if they apply:

**If PR contains database migrations or data backfills:**

13. Task data-migration-expert(PR content) - Validates ID mappings match production, checks for swapped values, verifies rollback safety
14. Task deployment-verification-agent(PR content) - Creates Go/No-Go deployment checklist with SQL verification queries

**When to run migration agents:**
- PR includes migration files
- PR modifies columns that store IDs, enums, or mappings
- PR includes data backfill scripts
- PR changes how data is read/written
- PR title/body mentions: migration, backfill, data transformation, ID mapping

</conditional_agents>

### 4. Ultra-Thinking Deep Dive Phases

<ultrathink_instruction> For each phase below, spend maximum cognitive effort. Think step by step. Consider all angles. Question assumptions. And bring all reviews in a synthesis to the user.</ultrathink_instruction>

#### Phase A: Stakeholder Perspective Analysis

<thinking_prompt> ULTRA-THINK: Put yourself in each stakeholder's shoes. What matters to them? What are their pain points? </thinking_prompt>

<stakeholder_perspectives>

1. **Developer Perspective**
   - How easy is this to understand and modify?
   - Are the APIs intuitive?
   - Is debugging straightforward?
   - Can I test this easily?

2. **Operations Perspective**
   - How do I deploy this safely?
   - What metrics and logs are available?
   - How do I troubleshoot issues?
   - What are the resource requirements?

3. **End User Perspective**
   - Is the feature intuitive?
   - Are error messages helpful?
   - Is performance acceptable?
   - Does it solve my problem?

4. **Security Team Perspective**
   - What's the attack surface?
   - Are there compliance requirements?
   - How is data protected?
   - What are the audit capabilities?

</stakeholder_perspectives>

#### Phase B: Scenario Exploration

<thinking_prompt> ULTRA-THINK: Explore edge cases and failure scenarios. What could go wrong? How does the system behave under stress? </thinking_prompt>

<scenario_checklist>

- [ ] **Happy Path**: Normal operation with valid inputs
- [ ] **Invalid Inputs**: Null, empty, malformed data
- [ ] **Boundary Conditions**: Min/max values, empty collections
- [ ] **Concurrent Access**: Race conditions, deadlocks
- [ ] **Scale Testing**: 10x, 100x, 1000x normal load
- [ ] **Network Issues**: Timeouts, partial failures
- [ ] **Resource Exhaustion**: Memory, disk, connections
- [ ] **Security Attacks**: Injection, overflow, DoS
- [ ] **Data Corruption**: Partial writes, inconsistency
- [ ] **Cascading Failures**: Downstream service issues

</scenario_checklist>

### 5. Simplification and Minimalism Review

Run the Task code-simplicity-reviewer() to see if we can simplify the code.

### 6. Findings Synthesis and Bead Creation

<critical_requirement> ALL findings MUST be stored as child beads of the reviewed bead. Create beads immediately after synthesis - do NOT present findings for user approval first. </critical_requirement>

#### Step 1: Synthesize All Findings

<thinking>
Consolidate all agent reports into a categorized list of findings.
Remove duplicates, prioritize by severity and impact.
</thinking>

- [ ] Collect findings from all parallel agents
- [ ] Discard any findings that recommend deleting or gitignoring files in `.beads/memory/` (see Protected Artifacts above)
- [ ] Categorize by type: security, performance, architecture, quality, etc.
- [ ] Assign severity levels: P1 CRITICAL, P2 IMPORTANT, P3 NICE-TO-HAVE
- [ ] Remove duplicate or overlapping findings
- [ ] Estimate effort for each finding (Small/Medium/Large)

#### Step 2: Create Beads for All Findings

For each finding, create a child bead:

```bash
bd create "{finding title}" \
  --parent {BEAD_ID} \
  --type {bug|task|improvement} \
  --priority {1-5} \
  --tags "review,{category},{BEAD_ID}" \
  -d "## Issue
{Detailed description}

## Severity
{P1/P2/P3} - {Why this severity}

## Location
{file:line references}

## Why This Matters
{Impact and consequences}

## Validation Criteria
- [ ] {Test that must pass}
- [ ] {Behavior to verify}

## Testing Steps
1. {How to reproduce/test}
2. {Expected outcome}"
```

**Priority mapping:**
- P1 CRITICAL -> priority 1 (blocks closing original bead)
- P2 IMPORTANT -> priority 2 (should fix before closing)
- P3 NICE-TO-HAVE -> priority 3-5 (can defer)

#### Step 3: Link Critical Issues

For P1 findings, create blocking dependencies:

```bash
bd dep relate {FINDING_BEAD_ID} {ORIGINAL_BEAD_ID}
```

This ensures the original bead cannot be closed until critical issues are resolved.

#### Step 4: Log Knowledge

For significant findings, log knowledge:

```bash
bd comment add {BEAD_ID} "LEARNED: {key insight from review}"
bd comment add {BEAD_ID} "PATTERN: {pattern issue discovered}"
```

#### Step 5: Summary Report

After creating all beads, present comprehensive summary:

```
## Code Review Complete

**Review Target:** {BEAD_ID} - {title}
**Branch:** {branch-name}

### Findings Summary:

- **Total Findings:** [X]
- **P1 CRITICAL:** [count] - BLOCKS CLOSURE
- **P2 IMPORTANT:** [count] - Should Fix
- **P3 NICE-TO-HAVE:** [count] - Enhancements

### Created Beads:

**P1 - Critical (BLOCKS CLOSURE):**
- {BD-XXX}: {description}
- {BD-XXX}: {description}

**P2 - Important:**
- {BD-XXX}: {description}

**P3 - Nice-to-Have:**
- {BD-XXX}: {description}

### Review Agents Used:
- {list of agents}

### Next Steps:

1. **Address P1 Findings**: CRITICAL - must be fixed before closing
   - /beads-work {P1_BEAD_ID} for each critical finding
2. **Triage remaining**: /beads-triage {BEAD_ID}
3. **Resolve in parallel**: /beads-resolve-parallel {BEAD_ID}
4. **View all findings**: bd list --tags "review,{BEAD_ID}"
```

### 7. End-to-End Testing (Optional)

<detect_project_type>

**First, detect the project type from PR files:**

| Indicator | Project Type |
|-----------|--------------|
| `*.xcodeproj`, `*.xcworkspace`, `Package.swift` | iOS/macOS |
| `Gemfile`, `package.json`, `app/views/*` | Web |
| Both iOS files AND web files | Hybrid |

</detect_project_type>

After presenting the Summary Report, offer appropriate testing based on project type:

**For Web Projects:**
"Want to run browser tests on the affected pages?"
1. Yes - run browser tests
2. No - skip

**For iOS Projects:**
"Want to run Xcode simulator tests on the app?"
1. Yes - run Xcode tests
2. No - skip

### Important: P1 Findings Block Closure

Any P1 (CRITICAL) findings must be addressed before closing the bead. These are linked as blocking dependencies and will prevent `bd close {BEAD_ID}` from succeeding until resolved.

## Notes

- Each reviewer creates beads for issues found (not markdown files or comments)
- Each bead has a thorough description with severity level, validation criteria, and testing steps
- Critical issues (P1) automatically block the original bead via dependencies
- Beads are tagged with `review,{BEAD_ID}` for easy filtering
- Use `/beads-work {ISSUE_BEAD_ID}` to fix issues found
- The original bead cannot be closed until all blocking dependencies are resolved
